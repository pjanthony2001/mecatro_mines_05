#include "PWM.h"

#include "Arduino_LED_Matrix.h"
#include <Wire.h>
#include "WiFiS3.h"

#include "Parameters.h"
#include "Motor.h"
#include "Timers.h"

unsigned int nIterControl, nIterTelemetry, nIterSample;
uint8_t eventLinkIndex;

volatile bool controlFlag = false;
volatile bool telemetryFlag = false;
volatile bool sampleFlag = false;

const unsigned int targetIterControl = 20 * CONTROL_INTERVAL; // Timer is running at 20kHz
const unsigned int targetIterTelemetry = 20 * MESSAGE_INTERVAL; 
const unsigned int targetIterSample = 20 * SAMPLE_INTERVAL;

#define SDA1_PIN 25 // pins for the Qwiic connector
#define SCL1_PIN 26

inline void iterationFlagUpdate(unsigned int& nIter, const unsigned int targetIter, volatile bool& flag) { // inline forces compiler to put logic directly in callback
    if (++nIter == targetIter) {
        flag = true; // Turn the flag on
        nIter = 0; // reset iteration
    }
}


void timerOverflowCallback() {
    // Reset the interrupt link
    R_ICU->IELSR[eventLinkIndex] &= ~(R_ICU_IELSR_IR_Msk);
    R_GPT7->GTST &= ~(R_GPT0_GTST_TCFPO_Msk);

    iterationFlagUpdate(nIterControl, targetIterControl, controlFlag);
    iterationFlagUpdate(nIterTelemetry, targetIterTelemetry, telemetryFlag);
    iterationFlagUpdate(nIterSample, targetIterSample, sampleFlag);
}

void configureMotorDirections() {
    // Configure direction pins as output
    pinMode(DIRECTION_MOTOR_RIGHT, OUTPUT);
    pinMode(DIRECTION_MOTOR_LEFT, OUTPUT);

}

void configureMotorTimers() {
    // Motor signal generation: we need configure the Arduino to generate a high-frequency signal
    // (typically 5-20kHz).
    // This is done using hardware PWM, i.e. the signal is generated by a timer physically present
    // in the microcontroller, not software running inside the CPU. This allows fast and accurate signal
    // generation, and takes absolutely no processing power.
    // Such timers exist on all microcontrollers, but each family has a difference interface.
    // The Arduino R4 uses a RA4M1, which describes its timers in Chapter 22 of the documentation.
    // Specifically, we use GPT167 maped to pin 9 (port B) and GPT162 to pin 10 (port A) , in saw-wave PWM mode.

    // First we enable the timers, and unlock the PWM registers
    R_MSTP->MSTPCRD &= ~(1 << R_MSTP_MSTPCRD_MSTPD6_Pos);
    R_GPT7->GTWP = 0xA500;


    // Now we configure the PWM, according to FIgure 22.30.
    R_GPT7->GTCR = 0; // Saw-wave PWM, no prescaller
    R_GPT7->GTUDDTYC = 0b01; // Up-counting
    R_GPT7->GTPR = 2399; // 20kHz frequency (MCU at 48MHz)
    R_GPT7->GTCNT = 0; // Reset counter
    R_GPT7->GTIOR = 0b100011001 << 16; // Signal form: high before compare match.
    R_GPT7->GTCCR[1] = 0; // Make sure the motor starts off

    R_GPT2->GTCR = 0; // Saw-wave PWM, no prescaller
    R_GPT2->GTUDDTYC = 0b01; // Up-counting
    R_GPT2->GTPR = 2399; // 20kHz frequency (MCU at 48MHz)
    R_GPT2->GTCNT = 0; // Reset counter
    R_GPT2->GTIOR = 0b100011001; // Signal form: high before compare match.
    R_GPT2->GTCCR[0] = 0; // Make sure the motor starts off


    // Finally we set these pins to the corresponding function
    R_PFS->PORT[3].PIN[3].PmnPFS = (1 << R_PFS_PORT_PIN_PmnPFS_PDR_Pos) | (1 << R_PFS_PORT_PIN_PmnPFS_PMR_Pos) | (3 << R_PFS_PORT_PIN_PmnPFS_PSEL_Pos);
    R_PFS->PORT[1].PIN[3].PmnPFS = (1 << R_PFS_PORT_PIN_PmnPFS_PDR_Pos) | (1 << R_PFS_PORT_PIN_PmnPFS_PMR_Pos) | (3 << R_PFS_PORT_PIN_PmnPFS_PSEL_Pos);

    // And start the timers
    R_GPT2->GTCR |= 1;
    R_GPT7->GTCR |= 1;

}

void configureInterruptCallback() {

    // Now we an interrupt callback on timer 7 overflow. This generates a 20kHz callback which we use for control
    // loop. Note that one could easily use another timer to decorrelate this frequency from that of the motor
    // driver, for as long as we are only interested in multiples of 100us I saw no need for that.


    timer_cfg_t base;
    base.channel = 7;
    base.cycle_end_irq = FSP_INVALID_VECTOR;
    TimerIrqCfg_t iCfg;
    iCfg.base_cfg = &base;
    gpt_extended_cfg_t fake;
    iCfg.gpt_ext_cfg = &fake;

    if (IRQManager::getInstance().addTimerOverflow(iCfg, timerOverflowCallback))
    {
        eventLinkIndex = iCfg.base_cfg->cycle_end_irq;
        R_BSP_IrqDisable((IRQn_Type)eventLinkIndex);
        R_BSP_IrqStatusClear((IRQn_Type)eventLinkIndex);
        NVIC_SetPriority((IRQn_Type)eventLinkIndex, 14); // is this high priority?
        R_BSP_IrqEnable((IRQn_Type)eventLinkIndex);
    }
}

void configureI2C() {
    // Manually clock the I2C output, so that all connected devices reset/timeout.
    pinMode(SCL1_PIN, OUTPUT);
    pinMode(SDA1_PIN, INPUT_PULLUP);
    for (int i = 0; i < 9; i++) {
        digitalWrite(SCL1_PIN, HIGH);
        delayMicroseconds(5);
        digitalWrite(SCL1_PIN, LOW);
        delayMicroseconds(5);
    }

    // I2C configuration
    // Set I2C clock speed to 400kHz (fast mode)
    // Note: this has to be done after starting the encoder, because their code reset the clock to 100kHz.
    Wire1.setClock(400000);
    // Set I2C master timeout to 500us - this line is very important, otherwise the Arduino can enter into an endless loop
    // when trying - and failing - to talk to the IMU.
    Wire1.setTimeout(500);
    Wire1.begin();
}

void configureArduino() {
    // Stop interrupts while configuring registers.
    __disable_irq();

    configureMotorDirections();;
    configureMotorTimers();
    configureInterruptCallback();
    
    __enable_irq();

    configureI2C();
}

bool isControlFlag() {return controlFlag;}
bool isTelemetryFlag() {return telemetryFlag;}
bool isSampleFlag() {return sampleFlag;}

bool resetControlFlag() {controlFlag = false;}
bool resetTelemetryFlag() {telemetryFlag = false;}
bool resetSampleFlag() {sampleFlag = false;}